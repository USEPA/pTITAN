---
title: "pTITAN2"
subtitle: "Permutation of Treatment Labels and Threshold Indicator Taxa ANalysis"
author: "Stephanie Figary^1^, Peter E. DeWitt^2,3,4^, and Naomi Detenbeck^5^"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteIndexEntry{pTITAN2}
 %\VignetteEncoding{UTF-8}
---

^1^former ORISE participant at U.S. Environmental Protection Agency, Atlantic Coastal Environmental Sciences Division, 27 Tarzwell Drive, Narragansett, RI, 02882, USA </br>
^2^Section of Informatics and Data Science, Department of Pediatrics, University of Colorado School of Medicine, Aurora Colorado, USA </br>
^3^National Renewable Energy Laboratory, Golden Colorado, USA </br>
^4^(formerly) Neptune and Company, Inc. Lakewood Colorado, USA </br>
^5^U.S. Environmental Protection Agency, Atlantic Coastal Environmental Sciences Division, 27 Tarzwell Drive, Narragansett, RI 02882, USA </br>


```{r label=setup, include = FALSE}
library(knitr)
knitr::opts_chunk$set(collapse = TRUE)
```

## Abstract

Taxa Indicator Threshold ANalysis (TITAN) was developed by Baker and King in
2010 to identify thresholds along environmental gradients where rapid changes in
taxa frequency and relative abundance are observed. TITAN determines separate
changepoints for increasing and decreasing taxa, as well as individual taxa,
with associated confidence intervals generated via bootstrapping. A new R
package, pTITAN2, is an extension to the TITAN2 package and was developed to
enable comparisons of TITAN output between treatments by permutating the
observed data between treatments and rerunning TITAN on the permuted data. There
are some limitations on the permutations, including (1) a site cannot occur in a
category more than once, the same limitation as in the original TITAN runs and
(2) the original sample size distribution is maintained. This addresses
potential sample size effects and enables comparisons between treatments with
different sampling sizes more accurately than using nonoverlapping confidence
intervals. Nonoverlapping confidence intervals can indicate significant
differences, but overlapping confidence intervals do not necessarily mean the
null hypothesis needs to be rejected. A vignette is provided based on a dataset
of macroinvertebrate data from California streams which fall along a gradient of
watershed percent impervious cover. We compare changepoints among different
climate conditions (wet, average, and dry) based on the Palmer Drought Severity
Index, which serve as the treatments in this example.

**Keywords:** TITAN, permutations, thresholds, community composition

# Introduction

Community ecologists are interested in understanding the structure and
interactions of multiple species in a given area or habitat type and many are
interested in understanding how communities change in response to changing
environmental or anthropogenic gradients. One method a community ecologist can
use for understanding to detect changes or ecological thresholds across
environmental gradients is Taxa Indicator Threshold ANalysis (TITAN)
[@baker2010new]. TITAN is useful for determining the impacts of environmental or
anthropogenic gradients such as upstream impervious cover (IC) in a watershed in
community ecology studies because it both analyzes each individual taxa response
and the community as a whole in the same analysis. Additionally, unlike other
community ecology methods, TITAN separates the taxa that increase across an
environmental gradient from those that decrease to provide a more complete
picture of the community response to that gradient.

As an overview, TITAN methods use change point
[@king2003integrating;@qian2003two] and indicator species analysis
[@dufrene1997species]
to determine the point along an environmental gradient, such as percent IC in the
upstream watershed area, where individual taxa have the largest change in
occurrence frequency and abundance, and then uses the individual taxa results to
determine synchronous areas of taxa change at the community level
[@baker2010new;@baker2013titan]
Individual taxa change points are determined by calculating
the taxa’s indicator (IndVal) score along the environmental gradient and
assigning the taxa as either increasing (z+) or declining (z-) in response to an
increase in the environmental gradient variable. Permutations of data in TITAN
runs are used to calculate the likelihood of random data generating a larger
IndVal score than the observed data and to standardize the taxa response to the
environmental gradient by calculating the taxa z-scores using permuted
distributions. Taxa z-scores are added together for increasing (z+) and
declining (z-) taxa along the environmental gradient and the point with the
highest sum(z-) and sum(z+) score is defined as the community change point.
Next, bootstrapping of observed data is used to calculate percentiles around the
community and individual taxa z-scores, and to determine if individual taxon
responses are pure and reliable. Purity is a measure of the proportion of
bootstrap results that match the taxa’s observed response group as either
increasing or declining. Reliability is the proportion of bootstraps with a low
probability (p &lt; 0.01) of random data having a higher IndVal score than the
bootstrapped observed data. Community change points are also calculated after
selecting (filtering) only the taxa that exceeded purity and reliability
requirements for the increasing (fsum(z+)) and declining (fsum(z-)) change
points. Narrow peaks around the maximum sum(z) or fsum(z) (filtered) scores
indicate areas with synchronous change in individual taxa frequency and
abundance and may indicate an ecological threshold along the environmental
gradient being evaluated. More information on TITAN methods can be found in
@baker2013titan or in the TITAN R package, TITAN2, [@R-TITAN2].

While TITAN is a powerful tool for community ecologist it requires additional
analysis for comparing results from different regions, groups or treatments.
Previously, researchers have used nonoverlapping confidence intervals for
changepoints from TITAN output to indicate significant differences between
groups [@king2011novel]. 2011). However, although nonoverlapping confidence intervals
can indicate significant differences, overlapping confidence intervals do not
necessarily mean the null hypothesis cannot be rejected
[@greenland2016statistical;@schenker2001judging].

We developed a new R package, pTITAN2, as an extension of the existing TITAN2 R
package [@R-TITAN2]. The goal of pTITAN2 is to enable comparisons of
TITAN output between treatments by permutating the observed data between
treatments and rerunning TITAN on the permuted data. There are some limitations
on the permutations, including (1) a sampling site cannot occur in a category
more than once, the same limitation as in the original TITAN runs and (2) the
original sample size distribution is maintained. This addresses potential sample
size effects and enables comparisons between treatments with different sample
sizes more accurately than using nonoverlapping confidence intervals. A vignette
is provided based on a dataset of macroinvertebrate data from California streams
that fall along a gradient of watershed percent impervious cover. We compare
changepoints among different climate conditions (wet, average, and dry) based on
the Palmer Drought Severity Index, which serve as the treatments in this
example.

To reproduce the examples in this vignette you will need to load and attach
the `pTITAN2` namespace and the `magrittr` namespace for the piping
operators.  `dplyr` is useful as several of the methods in pTITAN2 are based on
`dplyr` functions.

```{r }
set.seed(42)
library(pTITAN2)
library(magrittr)
library(dplyr)
```
# Example data

This vignette provides examples for using the pTITAN2 tools in
this package. Example data sets are from publicly available
macroinvertebrate survey data from California.
The data sets are broken down between the environmental
variable, in this case percent impervious cover, and macroinvertebrate data. Separate
data files are provided for each 'treatment' that is explored. In this case, the treatments
are data from either drought (dry) or normal precipitation years in the Chaparral region of California.

The data structure that is shown here is not required for pTITAN2. Instead the environmental
variables and treatments could be in a single data file and filtered/selected as needed.

```{r label="list-example-data-sets"}
list.files(system.file("extdata", package = "pTITAN2"))
```

File                 Data Type              Region       Treatment
----------------     ---------------------- -----------  ---------
`C_IC_D_06_wID.csv`  Environmental Gradient Chaparral    Dry
`C_IC_N_06_wID.csv`  Environmental Gradient Chaparral    Normal
`CD_06_Mall_wID.csv` Taxonomic              Chaparral    Dry
`CN_06_Mall_wID.csv` Taxonomic              Chaparral    Normal


# Selecting macroinvertebrate density data for TITAN

A new function in pTITAN2 is the occurrences function. This is an extension for
deciding the taxonomic detail to be included in a TITAN run based on `minSplt` in TITAN.
`minSplt` is minimum number of occurrences that TITAN is looking for
taxa to have across the provided sites. The `minSplt` default in TITAN is 5 and should never drop below 3.

There are two approaches for deciding the level of taxonomic detail to include in a
TITAN run. First, the analyst could decide to look at everything at a certain taxonomic level,
for example genus. In this approach every genus that did not have the minimum number of
occurrences would not be included. The second approach would be using the lowest taxonomic
detail on a case-by-case bias. This means retaining the lowest detail that meets the minimum number of
occurrences. In this approach if a genus had, for example, 5 occurrences it would be used. However, if
a family with three genuses each only had two occurrences, the family level would be used instead.
This is the approach that is used in the occurrences function where the `n` is the
minimum number of occurrences that are required for the TITAN runs.

**Example:**
The `CN_06_Mall.csv` (Chaparral Region, Treatment = Normal) file contains raw
macroinvertebrate density data for 500 possible macroinvertebrate codes for
each taxonomic level (class, order, family, genus). The `occurrences`
function selects the codes that should be used for the `TITAN2::titan` run.
The goal is to select the macroinvertebrate code with the most taxonomic
detail having at least `n` occurrences. Only one macroinvertebrate code will be
associated with the macroinvertebrate counts. For example, if there are at
least six occurrences at the genus level, the family, order, and class codes
would not be used in the `TITAN2::titan` run.


```{r }
CN_06_Mall_from_raw <-
  read.csv(file = system.file("extdata", "CN_06_Mall_wID.csv", package = "pTITAN2"),
           colClasses = c(StationID = "character"))
CD_06_Mall_from_raw <-
  read.csv(file = system.file("extdata", "CD_06_Mall_wID.csv", package = "pTITAN2"),
           colClasses = c(StationID = "character"))
```

You need not read the data from the raw files, the data sets have been provided
as ready to use data sets.

```{r}
data(CN_06_Mall_wID, CD_06_Mall_wID, package = "pTITAN2")
all.equal(CN_06_Mall_wID, CN_06_Mall_from_raw)
all.equal(CD_06_Mall_wID, CD_06_Mall_from_raw)

dim(CD_06_Mall_wID)
CD_06_Mall_wID[1:3, 1:6]
```

The names within the data set are expected to have the following structure:

* 8 characters in length
* characters 1 and 2 denote the class
* characters 3 and 4 denote the order
* characters 5 and 6 denote the family
* characters 7 and 8 denote the genus.

If no information at a level exists, use "00" to hold the place. For
example: A code that is 'Bi000000' is the Bivalvia class, while BiVe0000 is
the Bivalvia class, Veneroida order. BiVeSh00 is the Bivalvia class,
Veneroida order, Spheriridae family. BiVeSh01 is a genus within that family.

To have a sufficient number of observations for each code in the
`TITAN::titan()` runs we will only use those with at least `n` observations.
The code to use should be as granular as possible.
This means if a macroinvertebrate count has at least six occurrences in a genus
code, the family, order, and class codes associated with these counts should be
removed.  Or for another example, if there are too few counts at the genus level,
but at least 6 counts at the family level- the family code would be retained and
the order and class codes would be removed.

The function `occurrences` provides a `data.frame` with the `taxon`, as
provided and split into its component parts, and the counts.


```{r }
occurrences(CN_06_Mall_wID[, -1], n = 6L)
```

Compare these results to the (present) counts from the raw data:

```{r }
CN_06_Mall_wID %>%
  dplyr::select(-StationID) %>%
  tidyr::gather(key = 'taxon', value = 'count') %>%
  dplyr::mutate(Class = stringr::str_sub(.data$taxon, 1, 2),
                Order = stringr::str_sub(.data$taxon, 3, 4),
                Family = stringr::str_sub(.data$taxon, 5, 6),
                Genus  = stringr::str_sub(.data$taxon, 7, 8)) %>%
  dplyr::group_by(.data$Class, .data$Order, .data$Family, .data$Genus) %>%
  dplyr::summarize(taxon = unique(.data$taxon), count = sum(.data$count > 0)) %>%
  dplyr::ungroup() %>%
  dplyr::filter(count >= 6L) %>%
  dplyr::arrange(.data$Class, .data$Order, .data$Family, .data$Genus) %>% head(n=10)
```


Note that for `Class == "Ar"` there is only one row, with no `Order`, `Family`,
or `Genus` level information. That row is retained in the object returned from
`occurrences`.

The `Class == Bi` is more interesting. The `Order == "Un"` has no present
counts and is thus not reported in the object returned from `occurrences`.
The `BiVeCa01` should be reported, but not the `BiVeCa00`.  `BiVeSh00` should
also be reported. The `BiVe0000` and `Bi000000` should not be returned from
`occurrences` as preference for the codes with Family and Genus information
has been used.

For the resampling work to follow we will build the two taxonomic data sets
by selecting the columns for the taxon returned by `occurrences`

```{r }
chaparral_taxon_normal <-
  dplyr::select(CN_06_Mall_wID, StationID,
                occurrences(dplyr::select(CN_06_Mall_wID, -StationID), n = 6L)$taxon)
chaparral_taxon_dry <-
  dplyr::select(CD_06_Mall_wID, StationID,
                occurrences(dplyr::select(CD_06_Mall_wID, -StationID), n = 6L)$taxon)

chaparral_taxon_normal
```


# Permuting of Treatment Labels

The second new function in the pTITAN2 is the permute function. This is the function
that is used to permute the data across treatment labels such
that each station has a non-zero probability of being assigned to each
treatment, and that the stations are unique within each treatment and
replication.

For example, say we have stations A, B, C, D and E with treatments 1 and 2.
Let the Trt0 denote the initial treatment labels for the stations and Trt1,
Trt2, ... denote the permuted labels.

Station Trt0 Trt1 Trt2 Trt3 Trt4
------- ---- ---- ---- ---- ----
A       1    1    2    1    1
A       2    2    1    2    2
B       1    1    1    2    2
C       1    1    2    2    1
C       2    2    1    1    2
D       2    2    2    1    2
E       2    2    2    2    1

Notice that for station A and C in each of the permuted sets, one row is
assigned to treatment 1 and one to treatment 2, i.e., a station is not
replicated within a treatment level within a permutation.  For Stations B,
D, and E, the initial observations were for treatments 1, 2, and 2
respectively. The balance of 1, 2, 2 is maintained over the permutations.

The function `permute` is provided to generate a list of permuted sets of
taxa and environmental gradients.

Before we can run `permute`, we need to import the environmental gradients
data.

```{r }
data(C_IC_N_06_wID, C_IC_D_06_wID, package = "pTITAN2")
chaparral_envgrad_normal <- C_IC_N_06_wID
chaparral_envgrad_dry    <- C_IC_D_06_wID
str(chaparral_envgrad_normal)
str(chaparral_envgrad_dry)
```


```{r }
eg <- permute(
              taxa = list(chaparral_taxon_dry, chaparral_taxon_normal)
              ,
              envs = list(chaparral_envgrad_dry, chaparral_envgrad_normal)
              ,
              sid = "StationID"
              )
```

The result of the `permute` call is a list of lists.

```{r }
str(eg, max.level = 1L)
```

The first level denotes the treatment  In this example `Treatment1` is
the "dry" condition and the `Treatment2` is the "normal" condition, the order
of the inputs.

The second level are the data.frames for the treatment, the environmental
gradient and the taxonomic data.

```{r }
str(eg, max.level = 2L)
```


# Running `TITAN2::titan`

The most computationally expensive part of this work is calling
`TITAN2::titan` many, many times. A good option is to use the parallel
package to send the task of permuting the data and running `TITAN2::titan()`
to individual processing cores.  For the following example we will create a list
of inputs for four permutations of the data and then call `TITAN2::titan()`.

```{r}
set.seed(42)
permutations <- 
  replicate(4,
            {
              p <- permute(taxa = list(CD_06_Mall_wID, CN_06_Mall_wID),
                           envs = list(C_IC_D_06_wID, C_IC_N_06_wID),
                           sid = "StationID")
              trt_codes_1 <- subset(p$Treatment1$taxa, select = occurrences(p$Treatment1$taxa, n = 6L)$taxon)
              trt_codes_2 <- subset(p$Treatment2$taxa, select = occurrences(p$Treatment1$taxa, n = 6L)$taxon)

              out1 <- try(
                          TITAN2::titan(env  = p[["Treatment1"]][["env"]][[1]],
                                        txa  = trt_codes_1,
                                        boot = TRUE,
                                        nBoot = 5) #Change the number of bootstraps here
                          , silent = TRUE)

              out2 <- try(
                          TITAN2::titan(env  = p[["Treatment2"]][["env"]][[1]],
                                        txa  = trt_codes_2,
                                        boot = TRUE,
                                        nBoot = 5)
                          , silent = TRUE)
              
              if ("try-error" %in% c(class(out1), class(out2))) {
                rtn <- NULL
              } else {
                rtn <- data.frame("trt1cpsumz-" = out1$sumz.cp[1, 4], #decreasing taxa output
                                  "trt1cpsumz+" = out1$sumz.cp[2, 4], #increasing taxa output
                                  "trt1count" = (nrow(out1$env)), #Number of permuted sites in treatment #1 
                                  "trt2cpsumz-" = out2$sumz.cp[1, 4],
                                  "trt2cpsumz+" = out2$sumz.cp[2, 4],
                                  "trt2count" = (nrow(out2$env)))
              }
              rtn
            },
            simplify = FALSE)
permutations
```




**Example:**
Inputting data for TITAN, permuting the
data across treatments, using occurrences to select the data for the TITAN run,
and then running TITAN on the permuted and selected data.  The code for this
work is provided in a standalone script

```{r}
system.file("example-scripts", "permutation_example.R", package = "pTITAN2")
list.files(system.file("example-scripts", package = "pTITAN2"))
```

The output from this code is provided as a dataset in this package.
```{r }
permutation_example
```

The results are the increasing and decreasing taxa sumz values. In this example only four permutations are
used and TITAN bootstrapping is limited to five iterations. In an actual analysis these values should
be much higher. This process is very computationally intensive and can take hours or days to run
depending on the available computing power and the number of bootstraps and permutations used.




# Permuting Three or more Treatments

If you have three or more treatments and need to permute over them with the
condition that no station will be in the same treatment more than once on any
particular permutation and that all treatment labels are viable for each
station then you can still use the `permute` function. The foo function (above)
will need to be adjusted to include the additional treatments.


# Analyzing the results
The output from the above code chunk can then be used to compare the differences in change-point
values for treatments from the observed samples versus the permuted samples. A p-value test can be
run on these data to test for statistically significant differences between the treatment effects.

```{r}
#Run TITAN on the observed data
CD_obs <- TITAN2::titan(
  env  = dplyr::select(chaparral_envgrad_dry, ImpCover),
             txa  = dplyr::select(chaparral_taxon_dry,
                            occurrences(dplyr::select(chaparral_taxon_dry,
                           Ar000000:Tu000000),
                                  n = 6)$taxon),
      ncpus = 3,
  numPerm = 50,
  nBoot = 50)

CN_obs  <- TITAN2::titan(
  env  = dplyr::select(chaparral_envgrad_normal, ImpCover),
             txa  = dplyr::select(chaparral_taxon_normal,
                            occurrences(dplyr::select(chaparral_taxon_normal,
                           Ar000000:Tu000000),
                                  n = 6)$taxon),
      ncpus = 3,
  numPerm = 50,
  nBoot = 50)

# create a table of the median change point from TITAN for calculating the p-values
TITAN_med <-  rbind(as.data.frame(CD_obs$sumz),
                    as.data.frame(CN_obs$sumz)) %>%
  cbind(run = c(rep("Tr1_CD", 4),
                rep("Tr2_CN", 4))) %>%
  cbind(sumz = rep(c("sumz-", "sumz+", "fsumz-", "fsumz+")))  %>%
  dplyr::select(run, sumz,  "0.50")  %>%
  tidyr::pivot_wider(names_from = run,
              values_from = "0.50") %>%
  dplyr::mutate(
    T1T2_abs = abs(Tr1_CD - Tr2_CN)
  )

# Create a summary table of the permutation data
perm <- dplyr::bind_rows(permutation_example, .id = "permutation") #permutation_example is the permuated data

tr1_filt <-
  dplyr::select(perm, permutation, `trt1cpsumz-`,	`trt1cpsumz+`) %>%
  tidyr::pivot_longer(cols = `trt1cpsumz-`:`trt1cpsumz+`,
              values_to = "Tr1_CD",
              names_to = "sumz")

tr1_filt[which(tr1_filt$sumz == "trt1cpsumz-"), 2] <- "fsumz-"
tr1_filt[which(tr1_filt$sumz == "trt1cpsumz+"), 2] <- "fsumz+"

tr2_filt <-
  dplyr::select(perm, permutation, `trt2cpsumz-`,	`trt2cpsumz+`) %>%
  tidyr::pivot_longer(cols = `trt2cpsumz-`:`trt2cpsumz+`,
               values_to = "Tr2_CN",
               names_to = "sumz")
tr2_filt[which(tr2_filt$sumz == "trt2cpsumz-"), 2] <- "fsumz-"
tr2_filt[which(tr2_filt$sumz == "trt2cpsumz+"), 2] <- "fsumz+"


# mutate the data and create a summary table for calculating p-values
out_perm <- left_join(tr1_filt, tr2_filt) %>%
  mutate(
    T1T2_abs = abs(Tr1_CD - Tr2_CN)
  ) %>% select(-permutation)

# Calulate the p-values
tibble(treatment = "T1T2_CDCN",
                  "fsumz-" = (sum((
  filter(out_perm, sumz == "fsumz-")$T1T2_abs >
    (filter(TITAN_med, sumz == "fsumz-")$T1T2_abs)
)) + 1) / 1001, "fsumz+" =
  (sum((
    filter(out_perm, sumz == "fsumz+")$T1T2_abs >
      (filter(TITAN_med, sumz == "fsumz+")$T1T2_abs)
  )) + 1) / 1001)


```


# Session Info


```{r }
print(sessionInfo(), local = FALSE)
```

# References

